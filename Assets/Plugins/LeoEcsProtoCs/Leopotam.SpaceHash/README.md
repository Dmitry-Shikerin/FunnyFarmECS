<p align="center">
    <img src="./logo.png" alt="Logo">
</p>

# Space Hash
Реализация хеширования конечного 2D/3D пространства для быстрого поиска объектов в определенном радиусе.

> **ВАЖНО!** Требует C#9 (или Unity >=2021.2).

> **ВАЖНО!** Не забывайте использовать `DEBUG`-версии билдов для разработки и `RELEASE`-версии билдов для релизов: все внутренние проверки/исключения будут работать только в `DEBUG`-версиях и удалены для увеличения производительности в `RELEASE`-версиях.

> **ВАЖНО!** Проверено на Unity 2021.3 (не зависит от нее) и содержит asmdef-описания для компиляции в виде отдельных сборок и уменьшения времени рекомпиляции основного проекта.


# Социальные ресурсы
[Официальный блог](https://leopotam.com)


# Установка


## В виде исходников
Поддерживается установка в виде исходников из архива, который надо распаковать в проект.


## Прочие источники
Официальные версии выпускаются для активных подписчиков в виде ссылок на актуальные версии.


# Основные типы 


## SpaceHash2
Представляет собой хеширование конечного 2D-пространства регулярной сеткой для быстрого поиска объектов в определенном радиусе.
Экземпляр создается с явным указанием шага сетки и размеров пространства (все объекты вне этого пространства будут автоматически включаться в пограничные клетки, ухудшая производительность в поиске по ним):
```c#
SpaceHash2<string> spaceHash = new SpaceHash2<string> (
    10f, // Размер одной клетки.
    0f, 0f, // Минимальные X,Y координаты пространства.
    100f, 100f); // Максимальные X,Y координаты пространства.
```

> **ВАЖНО!** Идентификатор объекта задается пользователем в качестве типа обобщения (может быть любым типом), в примерах будет использоваться тип `string`.

Объекты являются точками без размеров и могут добавляться в любом количестве в хеш:
```c#
// В данном случае идентификатором была выбрана строка,
// но это может быть число, идентификатор сущности и т.д.
spaceHash.Add ("p1", 1f, 1f);
// Добавляем объект "p2" по координатам (15f, 15f).
spaceHash.Add ("p2", 15f, 15f);
// Добавляем объект "p3" по координатам (20f, 20f).
spaceHash.Add ("p3", 20f, 20f);
```

После добавления всех объектов можно выполнять поиск объектов, находящихся в указанной точке с определенным радиусом:
```c#
// Возвращает все объекты пространства в радиусе 1f от точки (20f, 0f),
// отсортированные по дистанции по возрастанию. Если объект существует
// в точке запроса, то он не будет участвовать в поиске.
float x = 20f;
float y = 0f;
float radius = 1f;
bool selfIgnore = true;
List<SpaceHashHit<string>> res = spaceHash.Get (x, y, radius, selfIgnore);
// SpaceHashHit:
// Поле Id - идентификатор объекта требуемого типа, в данном случае строка.
// Поле DistSqr - квадрат расстояния от запрошенной точки.
```
> **ВАЖНО!** Рекомендуется держать размер радиуса поиска в пределах 1-2 размеров шага сетки пространства. Это не ограничение, а рекомендация, размер сетки следует подбирать под задачу и проводить замеры производительности и потребления памяти.

Для уменьшения аллокаций список результатов может быть использован повторно, для этого его следует передать опциональным параметром:
```c#
List<SpaceHashHit<string>> res = spaceHash.Get (20f, 0f, 1f, true);
// Переиспользование списка без новых аллокаций.
res = spaceHash.Get (20f, 0f, 1f, true, res);
```

Если нужен только один самый ближайший объект, то можно воспользоваться следующим методом:
```c#
(SpaceHashHit<string> res, bool ok) = spaceHash.GetOne (20f, 0f, 1f, true);
```
В этом случае вернется успешность операции (найден объект или нет) и информация о нем.

Если нужно только узнать наличие любого объекта в радиусе без определения самого ближнего, то можно воспользоваться следующим методом:
```c#
bool found = spaceHash.Has (20f, 0f, 1f, true);
```

После запросов хеш можно очистить и переиспользовать для нового наполнения и запросов:
```c#
spaceHash.Clear ();
```

> **ВАЖНО!** Заполнение и очистка хеша не потокобезопасны и должны выполняться из основного потока. Запросы объектов из хеша потокобезопасны и могут выполняться из нескольких потоков.

Так же поддерживается поиск в пределах кольца, ограниченного внешним и внутренним радиусами - методы `HasInRing()`, `GetInRing()` и `GetOneInRing()` - функционал аналогичен `HasInRing()`, `GetInRing()` и `GetOneInRing()`, в параметрах внутренний радиус `intRadius`, а внешний радиус `extRadius`.


## SpaceHash3
Представляет собой хеширование конечного 3D-пространства регулярной сеткой для быстрого поиска объектов в определенном радиусе.
Весь функционал идентичен `SpaceHash2` за исключением поиска по кольцу, в параметры координат добавляется третья ось (Z).


# Лицензия
Расширение выпускается под коммерческой лицензией, [подробности тут](./LICENSE.md).
