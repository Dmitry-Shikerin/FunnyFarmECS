<p align="center">
    <img src="./logo.png" alt="Logo">
</p>

# Взаимоотношение родитель-ребенок для сущностей
Поддержка иерархических зависимостей между сущностями для LeoECS Proto.

> **ВАЖНО!** Требует C#9 (или Unity >=2021.2).

> **ВАЖНО!** Зависит от: **Leopotam.EcsProto**, **Leopotam.EcsProto.QoL**.

> **ВАЖНО!** Не забывайте использовать `DEBUG`-версии билдов для разработки и `RELEASE`-версии билдов для релизов: все внутренние проверки/исключения будут работать только в `DEBUG`-версиях и удалены для увеличения производительности в `RELEASE`-версиях.

> **ВАЖНО!** Проверено на Unity 2021.3 (не зависит от нее) и содержит asmdef-описания для компиляции в виде отдельных сборок и уменьшения времени рекомпиляции основного проекта.


# Социальные ресурсы
[Официальный блог](https://leopotam.com)


# Установка


## В виде исходников
Поддерживается установка в виде исходников из архива, который надо распаковать в проект.


## Прочие источники
Официальные версии выпускаются для активных подписчиков в виде ссылок на актуальные версии.


# Основные типы


## Родитель
Это специальный скрытый компонент, добавляющийся на сущность, вся работа с ним скрыта за апи
в аспекте модуля. Реализован в виде типа `ParentingParent`.


## Ребенок
Это специальный скрытый компонент, добавляющийся на сущность, вся работа с ним скрыта за апи
в аспекте модуля. Реализован в виде типа `ParentingChild`.


## Аспект
Все апи по управлению связями находится в аспекте с типом `ParentingAspect`
```c#
using Leopotam.EcsProto.Parenting;

[DI] readonly ParentingAspect _parenting = default;
// Настройка поведения в момент уничтожения родительской сущности -
// удалять зависимые сущности или нет. По умолчанию связанные сущности
// удаляются автоматически при удалении родительской сущности.
_parenting.KeepChildrenOnDead(parentE, true);

// Установка связи "Ребенок -> Родитель" между "childE -> parentE".
// Если childE был связан с другим родителем - старая связь будет прервана.
_parenting.SetParent(childE, parentE);

// Разрыв связи с родителем если была.
_parenting.ClearParent(childE);

// Устанавливалась ли связь с каким-то родителем (родитель может быть уже удален).
bool isChild = _parenting.IsParented (childE);

// Получение активной сущности родителя, флаг "ok" означает успех операции.
// Отсутствие ранее установленной связи считается провалом операции.
(ProtoEntity entity, bool ok) = _parenting.Parent(childE);

// Получение списка активных дочерних сущностей.
// Кеш результата может переиспользоваться многократно.
Slice<ProtoEntity> result = new ();
_parenting.Children (parentE, result);

// Вариант проверки, что связь была установлена, родитель был
// настроен на сохранение дочерних объектов после смерти и удален.
if (_parenting.IsParented(childE)) {
    var (entity, ok) = _parenting.Parent(childE);
    if (!ok) {
        // Очищаем связь с удаленным родителем.
        _parenting.ClearParent (childE);
        // Можно сделать специальную обработку для дочерней сущности.
        // ...
    }
}
```


# Подключение модуля


## Подключение в ручном режиме
Для подключения достаточно добавить аспект модуля `ParentingAspect` в аспект мира:
```c#
class Aspect1 : ProtoAspectInject {
    public readonly ParentingAspect Parenting;
    // Регистрация прочих аспектов.
}
```


## Подключение модуля целиком в автоматическом режиме
```c#
ProtoModules modules = new ProtoModules (
    new AutoInjectModule (),
    // Подключение прочих модулей.
    // ...
    new ParentingModule ()
);
_systems = new ProtoSystems (new ProtoWorld (modules.BuildAspect ()));
_systems
    // Подключение композитного модуля.
    .AddModule (modules.BuildModule ())
    // Остальная инициализация.
    .Init ();
```


# Лицензия
Расширение выпускается под коммерческой лицензией, [подробности тут](./LICENSE.md).
