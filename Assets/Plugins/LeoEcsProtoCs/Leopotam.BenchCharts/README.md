<p align="center">
    <img src="./logo.png" alt="Logo">
</p>

# Генерация графиков для результатов измерений

> **ВАЖНО!** Требует C#9 (или Unity >=2021.2).

> **ВАЖНО!** Проверено на Unity 2021.3 (не зависит от нее) и содержит asmdef-описания для компиляции в виде отдельных сборок и уменьшения времени рекомпиляции основного проекта.


# Социальные ресурсы
[Официальный блог](https://leopotam.com)


# Установка


## В виде исходников
Поддерживается установка в виде исходников из архива, который надо распаковать в проект.


## Прочие источники
Официальные версии выпускаются для активных подписчиков в виде ссылок на актуальные версии.


# Сборка графиков

Класс `BenchCharts` является точкой входа для построения графиков. Представляет собой генератор html-страницы, которую можно сохранить в файл и открыть в браузере:
```c#
BenchCharts charts = new ();
// Добавляем новый график.
BenchChart chartAi = charts.NewChart ()
    // Устанавливаем его заголовок.
    .SetTitle ("Оценка поведения ИИ")
    // Устанавливаем наименование его осей.
    .SetAxes ("Количество юнитов", "Опасность")
    // Устанавливаем подписи к меткам по оси X.
    .SetMarks ("0", "1", "2", "3", "4");
// Добавляем первый отчет в график.
chartAi.NewReport ("Вариант 1")
    // Наполняем первый отчет данными.
    .Add (0).Add (1).Add (2).Add (3).Add (4);
// Добавляем второй отчет в график.
chartAi.NewReport ("Вариант 2")
    // Наполняем второй отчет данными.
    .Add (0).Add (2).Add (4).Add (6).Add (8);
// Добавляем третий отчет в график.
chartAi.NewReport ("Вариант 3")
    // Наполняем третий отчет данными.
    .Add (0).Add (2.5f).Add (5).Add (7.5f).Add (10);
// Генерируем конечный html-файл с графиком.
string html = charts.Build ();
// Можем записать его в нужный файл,
// чтобы открыть позже в браузере.
File.WriteAllText ("Build/generated.html", html);
```
> **ВАЖНО!** Количество данных в каждом отчете регулируется количеством подписей к меткам при вызове `BenchChart.SetMarks()`. Все данные в каждом отчете сверх этого количества будут проигнорированы. Если данных наоборот не хватит - график оборвется на последнем значении.

> **ВАЖНО!** Количество графиков в одной генерации не ограничено.

> **ВАЖНО!** Количество отчетов в одном графике не ограничено.


# Измерение времени выполнения
Если не хочется использовать внешние системы измерения времени работы кода, то данный пакет предоставляет встроенный упрощенный вариант для этого. Сперва надо подготовить тесты, реализующие специальный интерфейс:
```c#
class SinTest : IBenchChartTest {
    double _res;
    // Метод служит для корректной инициализации
    // итерации "it" теста.
    public void OnInit (int it) { }    
    // Метод содержит тестируемый код
    // итерации "it" теста.
    public void OnRun (int it) {
        for (int i = 0; i < it * 100000; i++) {
            _res = Math.Sin (i);
        }
    }
    // Метод служит для корректной очистки
    // итерации "it" теста.
    public void OnDestroy (int it) { }
}

class CosTest : IBenchChartTest {
    double _res;

    public void OnInit (int it) { }

    public void OnRun (int it) {
        for (int i = 0; i < it * 100000; i++) {
            _res = Math.Cos (i);
        }
    }

    public void OnDestroy (int it) { }
}
```
Подготовленные тесты можно запустить и по результатам построить графики:
```c#
BenchCharts charts = new ();
BenchChart chartSinCos = charts.NewChart ()
    .SetTitle ("Измерение скорости")
    .SetAxes ("Количество итераций, сотни тыс.", "Время, мс.")
    .SetMarks ("0", "1", "2", "3", "4");
// Создаем отчет "sin" и заполняем его результатами запуска теста.
BenchChartRunner.Start (new SinTest (), chartSinCos.NewReport ("sin"));
// Создаем отчет "cos" и заполняем его результатами запуска теста.
BenchChartRunner.Start (new CosTest (), chartSinCos.NewReport ("cos"));
// Генерируем конечный html-файл с графиком.
string html = charts.Build ();
File.WriteAllText ("Build/generated.html", html);
```

# Лицензия
Расширение выпускается под коммерческой лицензией, [подробности тут](./LICENSE.md).
