<p align="center">
    <img src="./logo.png" alt="Logo">
</p>

# AI GOAP
Реализация планировщика Goal Oriented Action Planning. Потокобезопасность, нулевые аллокации, отсутствие зависимостей от любого движка.

> **ВАЖНО!** Требует C#9 (или Unity >=2021.2).

> **ВАЖНО!** Не забывайте использовать `DEBUG`-версии билдов для разработки и `RELEASE`-версии билдов для релизов: все внутренние проверки/исключения будут работать только в `DEBUG`-версиях и удалены для увеличения производительности в `RELEASE`-версиях.

> **ВАЖНО!** Проверено на Unity 2021.3 (не зависит от нее) и содержит asmdef-описания для компиляции в виде отдельных сборок и уменьшения времени рекомпиляции основного проекта.


# Социальные ресурсы
[Официальный блог](https://leopotam.com)


# Установка


## В виде исходников
Поддерживается установка в виде исходников из архива, который надо распаковать в проект.


## Прочие источники
Официальные версии выпускаются для активных подписчиков в виде ссылок на актуальные версии.


# Основные типы 


## Условие
Это флаг/признак, имеющий только 2 состояния - `Да` или `Нет`.

## Состояние
Это набор `Условий`, описывающих общее состояние окружения ИИ в какой-то момент времени.

Реализовано в виде типа `GoapState`:
```c#
GoapState state = new()
state
    // Установка условия с индексом 0.
    .Set (0)
    // Сброс условия с индексом 3.
    .Unset (3);
// Так же можно проверить состояние условия с нужным индексом.
if (state.Has (0)) {
    // Условие с индексом 0 установлено.
}
```

> **ВАЖНО!** Количество `Условий` в `Состоянии` ограничено 64, допустимый диапазон он 0 до 63 включительно,
> без повторений. Если выйти за диапазон - будет брошено исключение в DEBUG-версии.

Для обеспечения уникальности и автонумерации можно использовать свой `Enum`-тип:
```c#
enum PizzaState {
    Hungry,
    PhoneNumberPresents,
    IngredientsPresents,
    PizzaOrdered,
    FoodPresents,
}
// Собираем состояние с установленным условием "голода"
GoapState state = new();
state.Set ((int) PizzaState.Hungry);
```


## Требование
Это набор из 2 `Состояний`, описывающих набор `Условий`, которые обязательно должны быть установлены и
набор условий, которые обязательно должны быть сброшены. Только в этом случае `Требование` считается выполненным.
Реализовано в виде типа `GoapClaims`:
```c#
// Требуем наличия условия "голода",
// условия "наличия телефона пиццерии"
// и отсутствие условия "наличия еды".
GoapClaims claims = new();
claims
    .Inc((int) PizzaState.Hungry)
    .Inc((int) PizzaState.PhoneNumberPresents)
    .Exc((int) PizzaState.FoodPresents);
```


## Действие
Абстрактное действие ИИ, которое имеет уникальное имя, сложность/стоимость, `Требование` в качестве условия срабатывания и изменение
текущего `Состояния` определенным образом на выходе.
Реализуется кастомным типом, реализующим интерфейс `IGoapAction`:
```c#
// Действие "готовки еды", требует "голода" и "наличия ингредиентов",
// как результат работы - поднимает условие "наличия еды".
class CookAction : IGoapAction<string> {
    // Уникальный идентификатор, который позволит определить действие позже.
    // Тип поля определяется ограничением в обобщении IGoapAction<T>.
    public string Id () => "Cook";

    // Метод вызывается один раз и служит для
    // настройки требований действия.
    public GoapClaims OnInit (GoapPlanner<string> planner) {
        return new GoapClaims ()
            .Inc ((int) PizzaConds3.Hungry)
            .Inc ((int) PizzaConds3.IngredientsPresents);
    }

    // Метод вызывается один раз и служит для изменения
    // текущего состояния результатами работы этого действия.
    public GoapState OnExit (in GoapState state) {
        return state.Set ((int) PizzaConds3.FoodPresents);
    }

    // Метод, определяющий сложность/стоимость действия.
    // Метод опциональный, может отсутствовать, по умолчанию
    // сложность/стоимость действия равна 1.0f.
    public float Cost () => 10f;
}
```


## Планировщик
Это обработчик, позволяющий по несвязанному списку `Действий` строить из
них последовательность, которая приведет от начального `Состояния` в конечное `Требование`.
Реализован в виде типа `GoapPlanner<T>`:
```c#
// Ограничение обобщения `GoapPlanner<T>` определяет тип
// идентификаторов действий.
GoapPlanner<string> planner = new(
    // В конструктор передается список всех действий
    // которые могут быть задействованы в плане, например:
    // "Звонок в пиццерию"
    new CallPhoneAction (),
    // "Ожидание доставки пиццы"
    new WaitOrderAction (),
    // "Приготовление еды из ингредиентов"
    new CookAction (),
    // "Употребление пищи"
    new EatAction ()
);
```

Для построения плана следует подготовить кеш результатов планирования, стартовое `Состояние`
и целевое `Требование`, затем вызвать метод `Run()`:
```c#
List<string> result = new();
bool valid = planner.Run (
    // Первый параметр - стартовое состояние.
    new GoapState ()
        .Set ((int) PizzaConds3.Hungry)
        .Set ((int) PizzaConds3.PhoneNumberPresents),
    // Второй параметр - целевое требование.
    new GoapClaims ()
        .Exc ((int) PizzaConds3.Hungry),
    // Третий параметр - кеш результатов планирования.
    result
);
```

Метод возвращает признак успешности планирования, а кеш результатов актуализируется только если план валиден:
```c#
if (valid) {
    string planItems = string.Join (",", result);
    // planItems = "Call,WaitOrder,Eat"
}
```

Если требуется узнать `Состояние` на момент завершения каждого `Действия` из плана, то можно воспользоваться
методом `RunWithState()`:
```c#
List<GoapActionState<string>> result = new();
bool valid = planner.RunWithState (
    new GoapState ()
        .Set ((int) PizzaConds3.Hungry)
        .Set ((int) PizzaConds3.PhoneNumberPresents),
    new GoapClaims ()
        .Exc ((int) PizzaConds3.Hungry),
    result
);
```

Метод возвращает признак успешности планирования, а кеш результатов актуализируется только если план валиден:
```c#
if (valid) {
    foreach (GoapActionState<string> item in result) {
        // item.Id - идентификатор действия.
        // item.State - состояние на момент завершения действия.
    }
}
```

> **ВАЖНО!** Вызовы методов `Run()`/`RunWithState()` планировщка потокобезопасны и могут использоваться из разных потоков.


# Лицензия
Расширение выпускается под коммерческой лицензией, [подробности тут](./LICENSE.md).
