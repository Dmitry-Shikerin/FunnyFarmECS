<p align="center">
    <img src="./logo.png" alt="Proto">
</p>

# LeoECS Proto Threads
Интеграция многопоточной обработки для LeoECS Proto.

> **ВАЖНО!** Требует C#9 (или Unity >=2021.2).

> **ВАЖНО!** Зависит от: **Leopotam.EcsProto**.

> **ВАЖНО!** Не забывайте использовать `DEBUG`-версии билдов для разработки и `RELEASE`-версии билдов для релизов: все внутренние проверки/исключения будут работать только в `DEBUG`-версиях и удалены для увеличения производительности в `RELEASE`-версиях.

> **ВАЖНО!** Проверено на Unity 2021.3 (зависит от нее) и содержит asmdef-описания для компиляции в виде отдельных сборок и уменьшения времени рекомпиляции основного проекта.


# Социальные ресурсы
[Официальный блог](https://leopotam.com)


# Установка


## В виде исходников
Поддерживается установка в виде исходников из архива, который надо распаковать в проект.


## Прочие источники
Официальные версии выпускаются для активных подписчиков в виде ссылок на актуальные версии.


# Использование с итератором
Итераторы `ProtoIt` и `ProtoItExc` расширяются новым методом, позволяющим распараллелить обработку на несколько потоков:
```c#
class MultiThreadSystem : IProtoRunSystem {
    [DI] Aspect1 _aspect;
    [DI] ProtoIt _unitsIt = new (It.Inc<Unit> ());
    
    // Ссылка на обработчик.
    ProtoThreadHandler _cb;
    float _deltaTime;

    public void Run () {
        // Сохраняем deltaTime, которое будем использовать в потоках.
        _deltaTime = Time.deltaTime;
        // Вызываем параллельную обработку данных в итераторе.
        // Каждый запущенный поток обработает не менее 100 сущностей.
        _unitsIt.RunParallel (_cb ??= cb, 100);
    }

    // Обработчик, который будет вызываться в отдельных потоках.
    void cb (ProtoThreadIt it) {
        // Трогать основной итератор _unitsIt тут нельзя!
        foreach (ProtoEntity e in it) {
            ref Unit unit = ref _aspect.Unit.Get (e);
            unit.Point += unit.Dir * (_deltaTime * unit.Speed);
        }
    }
}
```

> **ВАЖНО!** Использовать анонимные функции нельзя - это приведет к постоянным аллокациям.

> **ВАЖНО!** Использовать методы напрямую без явного сохранения в поле системы нельзя - это приведет к постоянным аллокациям.

> **ВАЖНО!** Использовать апи unity, апи мира или другие не потокобезопасные вызовы нельзя.

> **ВАЖНО!** Обращаться к другим итераторам или пулам компонентов не из списка компонентов текущего итератора крайне не рекомендуется - проверка контроля целостности в этом случае отсутствует.

Возможно использование локальных методов с тем же правилом доступа через поле системы:
```c#
class MultiThreadSystem : IProtoRunSystem {
    [DI] Aspect1 _aspect;
    [DI] ProtoIt _unitsIt = new (It.Inc<Unit> ());
    
    // Ссылка на метод с логикой обработки.
    ProtoThreadHandler _cb;
    float _deltaTime;

    public void Run () {
        // Сохраняем deltaTime, которое будем использовать в потоках.
        _deltaTime = Time.deltaTime;
        
        // Пользовательский код, который будет вызываться в отдельных потоках.
        void cb (ProtoThreadIt it) {
            foreach (ProtoEntity e in it) {
                ref Unit unit = ref _aspect.Unit.Get (e);
                unit.Point += unit.Dir * (_deltaTime * unit.Speed);
            }
        }
    
        // Вызываем параллельную обработку данных в итераторе.
        // Каждый запущенный поток обработает не менее 100 сущностей.
        _unitsIt.RunParallel (_cb ??= cb, 100);
    }
}
```

По умолчанию максимальное количество потоков равняется количеству ядер процессора (удвоенному в случае HT).
Это значение можно ограничить, передав новое значение третим параметром:
```c#
_unitsIt.RunParallel (_cb ??= cb, 100, 4);
```

> **ВАЖНО!** Этот пакет можно использовать на WebGL-платформе, в этом случае максимальное количество потоков всегда будет ограничено одним.


# Лицензия
Расширение выпускается под коммерческой лицензией, [подробности тут](./LICENSE.md).
